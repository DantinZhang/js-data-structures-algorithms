<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>封装二叉搜索树</title>
</head>

<body>
    <script>
        //二叉树节点类
        class Node {
            constructor(key) {
                this.key = key;
                this.left = null;
                this.right = null;
            }
        }

        //封装一个二叉搜索树
        class BinarySearchTree {
            constructor() {
                this.root = null;
            }

            //1.1插入数据
            insert(key) {
                //1.先生成新的节点
                let newNode = new Node(key);
                //2.判断有没有根节点
                if(this.root == null) {
                    //2.1如果没有根节点，那么当前插入的就是根节点
                    this.root = newNode;
                }else {
                    //2.2如果有根节点，就调用递归函数
                    this.insertRecursion(this.root, newNode);
                }
            }

            //1.2插入操作的递归函数（依次向下查找）
            insertRecursion(current, newNode) {
                //1.看一下要往哪边查找
                if(newNode.key < current.key){
                    //2.1向左查找
                    if(current.left == null) {
                        //3.1如果左节点为空，那么就直接插入
                        current.left = newNode;
                    }else {
                        //3.2如果左节点不为空，就递归调用，直到一直到叶子节点
                        this.insertRecursion(current.left, newNode);
                    }
                } else {
                    //2.2向右查找，同理
                    if(current.right == null) {
                        current.right = newNode;
                    } else {
                        this.insertRecursion(current.right, newNode);
                    }
                }
            }

            //2.1前序遍历的递归函数
            preOrderRecursion(node) {
                if(node == null) return false;
                console.log(node.key+'入栈');
                this.preOrderRecursion(node.left);
                //递归完成后调用的是上一个栈顶函数的下一个过程，所以来到了node.right
                this.preOrderRecursion(node.right);
            }
            //2.2前序遍历
            preOrderTraversal() {
                this.preOrderRecursion(this.root);
            }
        }

        //测试代码
        let bst = new BinarySearchTree();
        bst.insert(11);
        bst.insert(7);
        bst.insert(15);
        bst.insert(5);
        bst.insert(9);
        console.log(bst);
        bst.preOrderTraversal();

        //先搞清楚递归和函数调用栈
        function f(n) {
            console.log(n+' 入栈');
            if(n==0) return 0;
            f(n-1);
            console.log(n+' 出栈');
        }
        f(3);
    </script>
</body>

</html>